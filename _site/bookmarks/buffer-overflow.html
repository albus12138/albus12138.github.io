<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         Raphael__
    -->
    <meta charset="utf-8" />
    <title>缓冲区溢出攻击相关知识 | Raphael's Blog</title>
    <meta name="author" content="Raphael" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Raphael's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">Raphael</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
    </div>

    <style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/bookmarks/buffer-overflow" title="缓冲区溢出攻击相关知识">缓冲区溢出攻击相关知识</a></h1>
        <p class="entry-date">2015-03-21</p>
        <p>本文是coursera软件安全课程学习总结，算是梳理知识，细节太多，只写了要点。</p>

<h2 id="内存模型">内存模型</h2>

<p><img src="/images/buffer-overflow/1.png" /></p>

<h3 id="内存分配">内存分配</h3>

<p>使用malloc函数分配的内存在heap区域，stack从高地址向低地址生长，heap相反。</p>

<p><img src="/images/buffer-overflow/2.png" /></p>

<h3 id="函数调用时的堆栈变化">函数调用时的堆栈变化</h3>

<p>每当使用call指令进行函数调用时，都会将原来的eip寄存器中的值压栈，然后，将新的函数指针写入eip寄存器，这是由机器自动执行的，保存原eip的同时，将新的执行地址写入eip.详细过程可以关注我的博客中一篇详细描述堆栈变化的博文click here。</p>

<p>这里我们知道，一旦函数调用完毕，返回地址如果被修改（比如被修改成为恶意程序的入口地址），那么后果不堪设想。使用缓冲区溢出可以实现攻击 ，我们会在例子中给出解释。</p>

<p>接下来我们使用一个例子来形象的表示出函数调用时堆栈的变化</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">local1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">local2</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
        <span class="p">...</span>
        <span class="n">f</span><span class="p">(</span><span class="s">&quot;tom&quot;</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span> </code></pre></figure>

<p><img src="/images/buffer-overflow/3.png" /></p>

<h2 id="代码注入">代码注入</h2>

<p>如何进行代码注入？首先，我们需要把代码放入内存。其次，需要让eip指向我们的代码起始位置，才能执行它。</p>

<h3 id="将代码加载到内存">将代码加载到内存</h3>

<ul>
  <li>
    <p>代码必须是已编译的可执行机器码</p>
  </li>
  <li>
    <p>代码不能包括零，否则，零之后I/O函数将停止拷贝</p>
  </li>
  <li>
    <p>不能使用loder</p>
  </li>
</ul>

<p>我们的目标是执行一个我们可以操纵的shell,加载shell的代码被称为shellcode。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span>
       <span class="kt">char</span>  <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
       <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="err">“</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span><span class="err">”</span><span class="p">;</span>
       <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
       <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<h3 id="让已经加载的代码运行起来">让已经加载的代码运行起来</h3>

<p>由于在函数调用的末尾，需要将原eip值取出加载到eip寄存器，那么，如果我们修改了原eip的值，使其变为我们shellcode代码执行地址，那么函数返回后就执行shellcode。</p>

<p>可是，怎么知道我们的shellcode指令开始地址呢？因为如果地址不正确，CPU就故障了。</p>

<p>如果我们没有权限获取代码，我们当让不知道缓冲区距离ebp有多远，那么，我们怎么办呢？</p>

<ul>
  <li>尝试！不停尝试（这个看运气，而且几率不高）</li>
  <li>如果没有地址随机优化，那么每次堆栈都从一个固定的地址开始执行，而且堆栈一般不会很深，那么，可以知道esp大体在某个区间。可以使用 nop sleds 提高我们的命中几率。</li>
</ul>

<p>nop sleds:</p>

<p><img src="/images/buffer-overflow/4.png" /></p>

<p>以上我们讨论的就是所谓的stack smashing。</p>

<h2 id="其他内存攻击">其他内存攻击</h2>

<h3 id="堆溢出">堆溢出</h3>

<p>把缓冲区溢出的原理用在堆上，就是所谓的堆溢出。</p>

<h3 id="整数溢出">整数溢出</h3>

<p><img src="/images/buffer-overflow/5.png" /></p>

<h3 id="读溢出">读溢出</h3>

<p>读取了不该读取的内存</p>

<p>the Heartbleed bug 通过发送特定的消息，拥有bug的ssl服务器没有检查长度就将攻击者指定的返回字符串返回攻击者。因此，攻击者可以通过增大字符串长度，非法读取其他数据。</p>

<h3 id="被释放的指针再次使用">被释放的指针再次使用</h3>

<h2 id="格式化字符串攻击">格式化字符串攻击</h2>

<h3 id="正常情况下的printf函数">正常情况下的printf函数</h3>

<p><img src="/images/buffer-overflow/6.png" /></p>

<h3 id="不安全时">不安全时</h3>

<p><img src="/images/buffer-overflow/7.png" /></p>

<p>读取了调用者的数据！</p>

<p>举例：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="mi">100</span><span class="o">%</span> <span class="n">dave</span><span class="err">”</span><span class="p">);</span>
    <span class="c1">//Prints stack entry 4 byes above saved %eip </span>
    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">s</span><span class="err">”</span><span class="p">);</span> 
    <span class="c1">//Prints bytes pointed to by that stack entry </span>
    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">d</span> <span class="o">%</span><span class="n">d</span> <span class="o">%</span><span class="n">d</span> <span class="o">%</span><span class="n">d</span> <span class="err">…”</span><span class="p">);</span>
    <span class="c1">//Prints a series of stack entries as integers </span>
    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="mi">08</span><span class="n">x</span> <span class="o">%</span><span class="mi">08</span><span class="n">x</span> <span class="o">%</span><span class="mi">08</span><span class="n">x</span> <span class="o">%</span><span class="mi">08</span><span class="n">x</span> <span class="err">…”</span><span class="p">);</span>
    <span class="c1">// Same, but nicely formatted hex </span>
    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="mi">100</span><span class="o">%</span> <span class="n">no</span> <span class="n">way</span><span class="o">!</span><span class="err">”</span><span class="p">)</span><span class="s">&quot;</span>
    <span class="c1">//WRITES the number 3 to address pointed to by stack entry</span></code></pre></figure>

<h3 id="例子解释">例子解释</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;time.h&gt; </span><span class="cp"></span>

    <span class="kt">char</span> <span class="n">greeting</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello there</span>
    <span class="mf">1.</span> <span class="n">Receive</span> <span class="n">wisdom</span>
    <span class="mf">2.</span> <span class="n">Add</span> <span class="n">wisdom</span>
    <span class="n">Selection</span> <span class="o">&gt;</span><span class="s">&quot;;</span>
    <span class="kt">char</span> <span class="n">prompt</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Enter some wisdom</span>
    <span class="s">&quot;;</span>
    <span class="kt">char</span> <span class="n">pat</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Achievement unlocked!</span>
    <span class="s">&quot;;</span>
    <span class="kt">char</span> <span class="n">secret</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;secret key&quot;</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">infd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* stdin */</span>
    <span class="kt">int</span> <span class="n">outfd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* stdout */</span>

    <span class="cp">#define DATA_SIZE 128</span>

    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">_WisdomList</span> <span class="p">{</span>
      <span class="k">struct</span>  <span class="n">_WisdomList</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
      <span class="kt">char</span>    <span class="n">data</span><span class="p">[</span><span class="n">DATA_SIZE</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">WisdomList</span><span class="p">;</span> 

    <span class="k">struct</span> <span class="n">_WisdomList</span>  <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">write_secret</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">secret</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">pat_on_back</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pat</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">get_wisdom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;no wisdom</span>
    <span class="s">&quot;;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">WisdomList</span>  <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
          <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="s">&quot;</span>
    <span class="s">&quot;, 1);</span>
          <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">put_wisdom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">char</span>  <span class="n">wis</span><span class="p">[</span><span class="n">DATA_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> 
      <span class="kt">int</span>   <span class="n">r</span><span class="p">;</span>

      <span class="n">r</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">prompt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
      <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">gets</span><span class="p">(</span><span class="n">wis</span><span class="p">);</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

      <span class="n">WisdomList</span>  <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">WisdomList</span><span class="p">));</span>

      <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WisdomList</span><span class="p">));</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">wis</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">head</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">WisdomList</span>  <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
          <span class="k">while</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">v</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fptr</span>  <span class="n">ptrs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">get_wisdom</span><span class="p">,</span> <span class="n">put_wisdom</span> <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">char</span>  <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
          <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
          <span class="n">fptr</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pat_on_back</span><span class="p">;</span>
          <span class="n">r</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">outfd</span><span class="p">,</span> <span class="n">greeting</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
          <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">infd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
          <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
            <span class="n">fptr</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
            <span class="n">tmp</span><span class="p">();</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>本实验所有材料来自coursera软件安全课程。</p>

<p>这个例子包含两个缓冲区溢出攻击。主函数中包含一个全局缓冲区攻击，函数put_wisdom中的wis缓冲区是一个栈上的缓冲区溢出。</p>

<p>执行过程：</p>

<ul>
  <li>编译程序，gcc -fno-stack-protector -ggdb -m32 wisdom-alt.c -o wisdom-alt</li>
  <li>使用bash打开一个终端，运行./runbin.sh</li>
  <li>打开另一个终端，使用命令 gdb -p <code>pgrep wisdom-alt</code>调试</li>
</ul>

<p><img src="/images/buffer-overflow/8.png" /></p>

<h3 id="ptrs输入超过2的索引出现错误">ptrs输入超过2的索引出现错误</h3>

<p>回想之前的缓冲区溢出，如果我们输入的索引值恰好能到达fptr p = pat_on_back;中p的存储区域，那么就能读取到pat_on_back，进而执行该函数！</p>

<p>首先，确定p的地址：在启动运行gdb中print &amp;p和print buf:</p>

<p><img src="/images/buffer-overflow/9.png" /></p>

<p>通过计算，知道p在buf之前771675416个内存位置处，我们输入该数字：</p>

<p><img src="/images/buffer-overflow/10.png" /></p>

<p>发现我们获取到了到了pat_on_back函数指针！</p>

<h3 id="void-put_wisdomvoid函数中的栈上缓冲区溢出">void put_wisdom(void)函数中的栈上缓冲区溢出</h3>

<p>同样的原理，我们通过找到函数void put_wisdom(void) 被调用时缓冲区wis的地址和返回地址在内存中的差，用同样的方法，将我们函数指针write_secret的地址写入保存返回地址的内存区域，那么函数put_wisdom调用结束后，就会执行write_secret函数。</p>

        <div id="disqus_thread"></div>
		<script type="text/javascript">
		    /* * * CONFIGURATION VARIABLES * * */
		    var disqus_shortname = 'albus12138';
		    
		    /* * * DON'T EDIT BELOW THIS LINE * * */
		    (function() {
		        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		    })();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
        
            
            <li><a href="/blog/why-blog">我为什么写博客？</a></li>
            
            
        
        </ul>

        <h2>Coding</h2>
        <ul class="artical-list">
        
        
            
            <li><a href="/coding/python-re">Python正则表达式</a></li>
            
            
        
            
            <li><a href="/coding/xctf-carnival-wp">XCTF嘉年华体验赛 Re部分WriteUp</a></li>
            
            
        
            
            <li><a href="/coding/gctf-wp">GCTF Re&Mobile WriteUp</a></li>
            
            
        
            
            <li><a href="/coding/python-requests">Requests模块</a></li>
            
            
        
            
            <li><a href="/coding/iscc-2017-wp">ISCC2017 WriteUp</a></li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
        </ul>

        <h2>Bookmarks</h2>
        <ul class="artical-list">
        
        
            
            <li><a href="/bookmarks/ddos">免费DDOS攻击测试工具</a></li>
            
            
        
            
            <li><a href="/bookmarks/network-traffic-hijacking-2">网络流量攻击的危害</a></li>
            
            
        
            
            <li><a href="/bookmarks/network-traffic-hijacking">网络流量攻击</a></li>
            
            
        
            
            <li><a href="/bookmarks/resouces-for-learn-python">学习Python编程的11个资源</a></li>
            
            
        
            
            <li><a href="/bookmarks/buffer-overflow">缓冲区溢出攻击相关知识</a></li>
            
            
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>

    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();
            });
        })
        $(document).ready(function(){
            var id = Math.floor(Math.random()*5)+1;
            $(".aside").css("background-image","url(/images/bg-"+id+".jpg)");            
        })
    </script>
</body>
</html>
